const MAX_CLICK_MOVE = 5;
const THUMBNAIL_SIZE = 84;
const SELECTED_BOX_COLOR = '#FF00FF';
const OLD_BOX_COLOR = '#8B008B';
const DISABLE_COLOR = '#000000';
/* **** Leaflet **** */
// Base layers
//  .. OpenStreetMap
var osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', minZoom: 13, maxZoom: 21, maxNativeZoom: 19});
//  .. White background
var white = L.tileLayer("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX///+nxBvIAAAAH0lEQVQYGe3BAQ0AAADCIPunfg43YAAAAAAAAAAA5wIhAAAB9aK9BAAAAABJRU5ErkJggg==", {minZoom: 13, maxZoom: 21});

// Overlay layers (TMS)
var lyr = L.tileLayer('/static/imgs/{z}/{x}/{y}.png', {tms: true, opacity: 1, attribution: "", minZoom: 13, maxZoom: 21});
var mlyr = L.tileLayer('/static/imgs/{z}/{x}/{y}.png', {tms: true, opacity: 1, attribution: "", minZoom: 13, maxNativeZoom: 21, maxZoom: 25});
// Map config
var map = L.map('map', {
	center: [16.546414031, -88.6959626251],
	zoom: 18,
	minZoom: 13,
	maxZoom: 21,
	layers: [osm, lyr],
	dragging: false,
	touchZoom: false,
	doubleClickZoom: false,
	scrollWheelZoom: false,
	zoomControl: false,
	boxZoom: false,
	keyboard: false,
	zoomAnimation: false,
});

// Minim/
var minimap = L.map('minimap', {
	center: [32.88398788, -117.234798816],
	zoom: 18,
	minZoom: 13,
	maxZoom: 30,
	maxNativeZoom: 21,
	touchZoom: false,
	doubleClickZoom: false,
	scrollWheelZoom: false,
	zoomControl: false,
	boxZoom: false,
	keyboard: false,
	zoomAnimation: false,
	layers: [mlyr],
	inertia: false
});

var basemaps = {"OpenStreetMap": osm, "Without background": white}
var overlaymaps = {"Layer": lyr}

// Note
var src = '<a href="ngs.ucsd.edu">Engineers for Exploration</a>, Generated by <a href="http://www.klokan.cz/projects/gdal2tiles/">GDAL2Tiles</a>, Copyright &copy; 2008 <a href="http://www.klokan.cz/">Klokan Petr Pridal</a>,  <a href="http://www.gdal.org/">GDAL</a> &amp; <a href="http://www.osgeo.org/">OSGeo</a> <a href="http://code.google.com/soc/">GSoC</a>';
var title = L.control({position: 'bottomleft'});
title.onAdd = function(map) {
	this._div = L.DomUtil.create('div', 'ctl src');
	this.update();
	return this._div;
};
title.update = function(props) {
	this._div.innerHTML = src;
};
title.addTo(map);


// The boxes that are drawn to show what is currently being selected
var box;
var minibox = L.rectangle([[0,0],[0,0]], {fill: false, color: SELECTED_BOX_COLOR});
// Locations where clicks on the maps started
var clickStart;
var miniStart;
// Keeps track of if the mouse has stayed in one place after being pressed
var click;
// An array of all areas selected so far
var boxes = [];

var imgUrl;

// The small squares on the corners of the minibox to resize it
var handleIcon = L.divIcon({iconSize: [10, 10], className: 'handle-icon'});
var neHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var nwHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var seHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var swHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});

// The corner that stays in place while a selection is being resized
var resizeAnchor;
// The corner that moves around while a selection is being resized
var resizeMove;

// Disable right click on maps
minimap.on('contextmenu', function(e) {});
map.on('contextmenu', function(e) {});

var mapBounds = [[0, 0], [0, 0]];

// Since leaflet shows a larger view than required,
// darken areas outside of current tile
// Selections in those areas aren't going to be kept anyway
var topBound = L.rectangle([[0,0],[0,0]], {clickable: false, stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var rightBound = L.rectangle([[0,0],[0,0]], {clickable: false, stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var leftBound = L.rectangle([[0,0],[0,0]], {clickable: false, stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var bottomBound = L.rectangle([[0,0],[0,0]], {clickable: false, stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);

// keep track of if any region is selected
selected = false;

// keep the bounds the same when the region is resized
// this method is also used to update when a new tile is retrieved
function updateBounds() {
  map.fitBounds(mapBounds);

  // update dark border area
  topBound.setBounds([[90, -180], [Math.max(mapBounds[0][0], mapBounds[1][0]), 180]]);
  rightBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), Math.max(mapBounds[0][1], mapBounds[1][1])],
                       [Math.max(mapBounds[0][0], mapBounds[1][0]), 180]]);
  leftBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), -180],
                       [Math.max(mapBounds[0][0], mapBounds[1][0]), Math.min(mapBounds[0][1], mapBounds[1][1])]]);
  bottomBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), -180], [-90, 180]]);
}
map.on('resize', updateBounds);

// control visibility of handles that let you resize the minibox
function showHandles() {
	updateHandles();
	neHandle.setOpacity(1);
	nwHandle.setOpacity(1);
	seHandle.setOpacity(1);
	swHandle.setOpacity(1);
}
function hideHandles() {
	neHandle.setOpacity(0);
	nwHandle.setOpacity(0);
	seHandle.setOpacity(0);
	swHandle.setOpacity(0);
}

function addMiniBox(amap) {
	minibox.addTo(amap);
	neHandle.addTo(amap);
	nwHandle.addTo(amap);
	seHandle.addTo(amap);
	swHandle.addTo(amap);
	updateHandles();
}
function removeMiniBox() {
	minibox.remove();
	neHandle.remove();
	nwHandle.remove();
	seHandle.remove();
	swHandle.remove();
  minimap.fitBounds([[0,0],[0,0]]);
}

// update handle positions to keep them on the corners of the minibox
function updateHandles() {
	neHandle.setLatLng(minibox.getBounds().getNorthEast());
	nwHandle.setLatLng(minibox.getBounds().getNorthWest());
	seHandle.setLatLng(minibox.getBounds().getSouthEast());
	swHandle.setLatLng(minibox.getBounds().getSouthWest());
}

function onHandleOver(e) {
	minimap.dragging.disable();
}
function onHandleOut(e) {
	minimap.dragging.enable();
}

neHandle.on('mouseover', onHandleOver);
nwHandle.on('mouseover', onHandleOver);
seHandle.on('mouseover', onHandleOver);
swHandle.on('mouseover', onHandleOver);
neHandle.on('mouseout', onHandleOut);
nwHandle.on('mouseout', onHandleOut);
seHandle.on('mouseout', onHandleOut);
swHandle.on('mouseout', onHandleOut);

// Methods to start resizing a selection
// The opposite corner from the one that is pressed is used as the anchor
neHandle.on('dragstart', function (e) {
	resizeAnchor = swHandle.getLatLng();
	resizeMove = neHandle;
	hideHandles();
});
nwHandle.on('dragstart', function (e) {
	resizeAnchor = seHandle.getLatLng();
	resizeMove = nwHandle;
	hideHandles();
});
seHandle.on('dragstart', function (e) {
	resizeAnchor = nwHandle.getLatLng();
	resizeMove = seHandle;
	hideHandles();
});
swHandle.on('dragstart', function (e) {
	resizeAnchor = neHandle.getLatLng();
	resizeMove = swHandle;
	hideHandles();
});

// Resizes the minimap box and the regular box while being dragged
function onResizeMove(e) {
	if (resizeAnchor != null) {
		minibox.setBounds([resizeAnchor, resizeMove.getLatLng()]);
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
		}
	}
}
neHandle.on('drag', onResizeMove);
nwHandle.on('drag', onResizeMove);
seHandle.on('drag', onResizeMove);
swHandle.on('drag', onResizeMove);

// Recenters the camera and resets dragging variables
function onResizeUp(e) {
	if (resizeAnchor != null) {
		minimap.fitBounds(minibox.getBounds());
		resizeAnchor = null;
		resizeMove = null;
		showHandles();
	}
}
neHandle.on('dragend', onResizeUp);
nwHandle.on('dragend', onResizeUp);
seHandle.on('dragend', onResizeUp);
swHandle.on('dragend', onResizeUp);

// Keep track of where the minimap was when it starts getting dragged
function onMiniDown(e) {
	miniStart = minimap.getBounds().getNorthEast();
	hideHandles();
}
minimap.on('dragstart', onMiniDown);

// Make minimap box stay centered while dragging around minimap
function onMiniMove(e) {
	if (miniStart != null) {
		// get how much the minimap view moved, and move the rectangle by that amount
		var offLat = minimap.getBounds().getNorth() - miniStart.lat;
		var offLng = minimap.getBounds().getEast() - miniStart.lng;
		minibox.setBounds([[minibox.getBounds().getSouth() + offLat, minibox.getBounds().getWest() + offLng],[minibox.getBounds().getNorth() + offLat, minibox.getBounds().getEast() + offLng]]);
		if ((boxes.length > 0) && selected) {
			// move the box on the normal map
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
		}
		miniStart = minimap.getBounds().getNorthEast();
	}
}
minimap.on('drag', onMiniMove);

// Reset things after a drag
function onMiniUp(e) {
	if (miniStart != null) {
		miniStart = null;
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
			showHandles();
		}
	}
}
minimap.on('dragend', onMiniUp);

// Starts a selection on the map
function onMouseDown(e) {
	clickStart = e;
	box = L.rectangle(L.latLngBounds(e.latlng, e.latlng), {fill: false, color: SELECTED_BOX_COLOR}).addTo(map);
	click = true;
  deselectBox();
  removeMiniBox();
}
map.on('mousedown', onMouseDown);

function onMouseUp(e) {
	// if the mouse is clicked, try to select an old box instead of making a new one
	if (click) {
		// check if the mouse in in a box
		for (var i = 0; i < boxes.length; i++) {
			var cell = boxes[i];
			// select box if it is clicked on
			if (cell.getBounds().contains(e.latlng)){
        selectBox(i);
				break;
			}
		}
		box.remove();
		clickStart = null;
		box = null;
	}

	// add the new selection to the list of boxes if the mouse was dragged
	if (box != null) {
    deselectBox();
    selected = true;
		clickStart = null;
		boxes.push(box)
    var list = document.getElementById("boxlist");

    var button = document.createElement("li");
    button.className = "boxlabel";
    button.id = box._leaflet_id;
    button.onclick = function() {
      for (var i = 0; i < boxes.length; i++) {
        var cell = boxes[i];
        if (cell._leaflet_id == button.id) {
          selectBox(i);
          break;
        }
      }
    };
    var bounds = box.getBounds();
    addThumbnail(button, bounds.getNorth(), bounds.getWest(), bounds.getSouth(), bounds.getEast(), 20);
    list.appendChild(button);
		box = null;
	}
  if (!selected) {
    minimap.setView(e.latlng, 21);
  }

	click = false;
}
map.on('mouseup', onMouseUp);

// Make a selection between the point where the mouse is and where it was initially pressed
function onMouseMove(e) {
	if (box != null) {
		// if the mouse hasn't moved much, it might just be a click and not a drag, so you shouldn't make a new box yet
		if (!click || e.layerPoint.distanceTo(clickStart.layerPoint) > MAX_CLICK_MOVE) {
			click = false;
			box.setBounds(L.latLngBounds(e.latlng, clickStart.latlng));
			minibox.addTo(minimap).setBounds(box.getBounds());
			addMiniBox(minimap);
			showHandles();
			minimap.fitBounds(box.getBounds());
		}
	} else if (!selected) {
    minimap.setView(e.latlng, 21);
  }
}
map.on('mousemove', onMouseMove);

// End the current selection when the mouse leaves the map
function onMouseOut(e) {
	if (box != null) {
		box.remove();
		clickStart = null;
		box = null;
    removeMiniBox();
	}
	click = false;
}
map.on('mouseout', onMouseOut);

// Remove the box at the end of the list of boxes, which should be the selected box
function undoBox() {
	if ((boxes.length > 0) && selected) {
    deselectBox();
    removeMiniBox();
		boxes[boxes.length - 1].remove();
    var button = document.getElementById(boxes[boxes.length-1]._leaflet_id);
    button.parentNode.removeChild(button);
		boxes.pop();
	}
}

// Remove all boxes
function clearBoxes() {
  deselectBox();
	for (var i = boxes.length - 1; i >= 0; i--) {
		boxes[i].remove();
		boxes.pop();
	}
  document.getElementById("boxlist").innerHTML = "";
	removeMiniBox();
}

var pending = 0;
var failed = false;
// Send boxes in a window
// TODO Have some kind of warning when sendBoxes is called with no selections
// 	 	in case someone accidentally pressed submit twice
function sendBoxes() {
	if (pending == 0) {
		failed = false;
    document.getElementById("message").innerHTML = "Sending Information...";
    document.getElementById("message").style.color = "#aa0";
		if (boxes.length == 0) {
			updateMap(false);
		}
		for (var i = boxes.length-1; i >= 0; i--) {
			pending++;
			var select = boxes[i];
			var data = [
				{name:"lat1", value:select.getBounds().getNorth()},
				{name:"lon1", value:select.getBounds().getEast()},
				{name:"lat2", value:select.getBounds().getSouth()},
				{name:"lon2", value:select.getBounds().getWest()}
			];
			data = data.concat($('#selection-form').serializeArray());
			$.post("/e4e/ml_training_map/harpy_web/tag/spawn/", data)
			.fail(function() {
        document.getElementById("message").innerHTML = "Some information failed to send";
        document.getElementById("message").style.color = "#a00";
				failed = true;
			})
			.always(function() {
				pending--;
				updateMap(false);
			});
		}
	}
}

function deselectBox() {
  if (boxes.length > 0) {
    boxes[boxes.length - 1].setStyle({fill: true, color: OLD_BOX_COLOR});
    var button = document.getElementById(boxes[boxes.length-1]._leaflet_id);
    button.style.backgroundColor = "#fff";
    selected = false;
  }
}
function selectBox(i) {
  var cell = boxes[i];
  deselectBox();
  removeMiniBox();
  boxes.splice(i, 1);
  boxes.push(cell);
  // update thumbnail border
  var button = document.getElementById(cell._leaflet_id);
  button.style.backgroundColor = "#f0f";
  cell.setStyle({fill: false, color: SELECTED_BOX_COLOR});
  if (boxes.length > 0) {
    boxes[boxes.length - 1].setStyle({fill: false, color: SELECTED_BOX_COLOR});
  }
  // update minimap for new selection
  if (!selected) {
    addMiniBox(minimap);
  }
  selected = true;
  minibox.setBounds(cell.getBounds());
  minimap.fitBounds(minibox.getBounds());
  updateHandles();
}

function pixelsToTile(px, py) {
  var tx = Math.ceil(px / 256);
  var ty = Math.ceil(py / 256);
  return [tx, ty];
}

// adds at thumbnail to an element
function addThumbnail(ele, la1, lo1, la2, lo2, zo) {
  // get the bounds of the view in pixels
  var topLeft = map.project([-Math.max(la1, la2), Math.min(lo1, lo2)], zo);
  var bottomRight = map.project([-Math.min(la1, la2), Math.max(lo1, lo2)], zo);
  // get which tile the pixels belong in 
  var tlTile = pixelsToTile(topLeft.x, topLeft.y);
  var brTile = pixelsToTile(bottomRight.x, bottomRight.y);
  for (var i = tlTile[1]; i >= brTile[1]; i--) {
    // get the top and bottom heights on the image tile that are part of the
    // thumbnail
    var south = 255 - (Math.max(bottomRight.y, 256 * (i - 1)) % 256);
    var north = 255 - (Math.min(topLeft.y, (256 * i) - 1) % 256);
    if (north < south) {
      // create a row of tiled images for the thumbnail
      var tr = document.createElement('div');
      tr.style.width = "100%";
      // set the height of the row
      // this could have used the height of the element the thumbnail will be in
      // instead of a constant, but it sometimes caused some problems with
      // dynamically created elements
      tr.style.height = ((south - north) * THUMBNAIL_SIZE / (topLeft.y - bottomRight.y)) + "px";
      tr.style.whiteSpace = "nowrap";
      for (var j = tlTile[0]; j <= brTile[0]; j++) {
        // do the same process as above, but with the columns of images
        var west = Math.max(topLeft.x, 256 * (j - 1)) % 256;
        var east = Math.min(bottomRight.x, (256 * j) - 1) % 256;
        if (west < east) {
          var td = document.createElement('span');
          td.style.height = "100%";
          td.style.width = ((east - west) * THUMBNAIL_SIZE / (bottomRight.x - topLeft.x)) + "px";
          td.style.overflow = "hidden";
          td.style.display = "inline-block";
          var img = document.createElement('img');
          img.draggable = false;
          img.src = "/static/imgs/" + zo + "/" + (j - 1) + "/" + (i-1) + ".png";

          // scale and pan the image so that the correct part of it is in the span
          img.style.height = 256 * THUMBNAIL_SIZE / (topLeft.y - bottomRight.y) + "px";
          img.style.width = 256 * THUMBNAIL_SIZE / (bottomRight.x - topLeft.x) + "px";
          img.style.margin = -(north * THUMBNAIL_SIZE / (topLeft.y - bottomRight.y)) + "px 0 0 " +
                             -(west * THUMBNAIL_SIZE / (bottomRight.x - topLeft.x)) + "px";
          td.appendChild(img);
          tr.appendChild(td);
        }

      }
      ele.appendChild(tr);
    }
  }
}

function updateMap(first) {
	if (pending == 0) {
		if (!failed) {
      // tell the server if this is the first tile of the session or not so that
      // it knows not tag the previous tile you viewed
			data = first ? [] : [{name:"complete", value:"yes"}];
			
      // get a new tile to view
			$.getJSON("/e4e/ml_training_map/harpy_web/tiles/retrieve/", data, function(response) {
				mapBounds = [[response.lat1, response.lon1], [response.lat2, response.lon2]];
        document.getElementById("message").innerHTML = "You've labeled " + response.tags + " tag" + (response.tags == 1 ? "" : "s") + " from " + response.tiles + " tile" + (response.tiles == 1 ? "" : "s");
        document.getElementById("message").style.color = "#0a0";
        $("#update").show();
        updateBounds();
				lyr.setUrl('/static/imgs/{z}/{x}/{y}.png');
				mlyr.setUrl('/static/imgs/{z}/{x}/{y}.png');

				clearBoxes();
			});
		}
	}
}

updateMap(true);
