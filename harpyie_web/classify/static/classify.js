const MAX_CLICK_MOVE = 5;
const SELECTED_BOX_COLOR = '#FF00FF';
const OLD_BOX_COLOR = '#8B008B';
const DISABLE_COLOR = '#000000';
/* **** Leaflet **** */
// Base layers
//  .. OpenStreetMap
var osm = L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', minZoom: 13, maxZoom: 21, maxNativeZoom: 19});
//  .. White background
var white = L.tileLayer("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAAA1BMVEX///+nxBvIAAAAH0lEQVQYGe3BAQ0AAADCIPunfg43YAAAAAAAAAAA5wIhAAAB9aK9BAAAAABJRU5ErkJggg==", {minZoom: 13, maxZoom: 21});

// Overlay layers (TMS)
var lyr = L.tileLayer('/static/imgs/{z}/{x}/{y}.png', {tms: true, opacity: 1, attribution: "", minZoom: 13, maxZoom: 21});
var mlyr = L.tileLayer('/static/imgs/{z}/{x}/{y}.png', {tms: true, opacity: 1, attribution: "", minZoom: 13, maxNativeZoom: 21, maxZoom: 25});
// Map config
var map = L.map('map', {
	center: [16.546414031, -88.6959626251],
	zoom: 18,
	minZoom: 13,
	maxZoom: 21,
	layers: [osm, lyr],
	dragging: false,
	touchZoom: false,
	doubleClickZoom: false,
	scrollWheelZoom: false,
	zoomControl: false,
	boxZoom: false,
	keyboard: false,
	zoomAnimation: false,
});

// Minim/
var minimap = L.map('minimap', {
	center: [32.88398788, -117.234798816],
	zoom: 18,
	minZoom: 13,
	maxZoom: 30,
	maxNativeZoom: 21,
	touchZoom: false,
	doubleClickZoom: false,
	scrollWheelZoom: false,
	zoomControl: false,
	boxZoom: false,
	keyboard: false,
	zoomAnimation: false,
	layers: [mlyr],
	inertia: false
});

var basemaps = {"OpenStreetMap": osm, "Without background": white}
var overlaymaps = {"Layer": lyr}

// Note
var src = 'Generated by <a href="http://www.klokan.cz/projects/gdal2tiles/">GDAL2Tiles</a>, Copyright &copy; 2008 <a href="http://www.klokan.cz/">Klokan Petr Pridal</a>,  <a href="http://www.gdal.org/">GDAL</a> &amp; <a href="http://www.osgeo.org/">OSGeo</a> <a href="http://code.google.com/soc/">GSoC</a>';
var title = L.control({position: 'bottomleft'});
title.onAdd = function(map) {
	this._div = L.DomUtil.create('div', 'ctl src');
	this.update();
	return this._div;
};
title.update = function(props) {
	this._div.innerHTML = src;
};
title.addTo(map);


// The boxes that are drawn to show what is currently being selected
var box;
var minibox = L.rectangle([[0,0],[0,0]], {fill: false, color: SELECTED_BOX_COLOR});
// Locations where clicks on the maps started
var clickStart;
var miniStart;
// Keeps track of if the mouse has stayed in one place after being pressed
var click;
// An array of all areas selected so far
var boxes = [];

var imgUrl;

// The small squares on the corners of the minibox to resize it
var handleIcon = L.divIcon({iconSize: [10, 10], className: 'handle-icon'});
var neHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var nwHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var seHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});
var swHandle = L.marker([0, 0], {draggable: true, icon: handleIcon});

// The corner that stays in place while a selection is being resized
var resizeAnchor;
// The corner that moves around while a selection is being resized
var resizeMove;

// Disable right click on maps
minimap.on('contextmenu', function(e) {});
map.on('contextmenu', function(e) {});

var mapBounds = [[0, 0], [0, 0]];

var topBound = L.rectangle([[0,0],[0,0]], {stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var rightBound = L.rectangle([[0,0],[0,0]], {stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var leftBound = L.rectangle([[0,0],[0,0]], {stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);
var bottomBound = L.rectangle([[0,0],[0,0]], {stroke: false, fillOpacity:0.5, color: DISABLE_COLOR}).addTo(map);

function updateBounds() {
  map.fitBounds(mapBounds);
  topBound.setBounds([[90, -180], [Math.max(mapBounds[0][0], mapBounds[1][0]), 180]]);
  rightBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), Math.max(mapBounds[0][1], mapBounds[1][1])],
                       [Math.max(mapBounds[0][0], mapBounds[1][0]), 180]]);
  leftBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), -180],
                       [Math.max(mapBounds[0][0], mapBounds[1][0]), Math.min(mapBounds[0][1], mapBounds[1][1])]]);
  bottomBound.setBounds([[Math.min(mapBounds[0][0], mapBounds[1][0]), -180], [-90, 180]]);
}
map.on('resize', updateBounds);

function showHandles() {
	updateHandles();
	neHandle.setOpacity(1);
	nwHandle.setOpacity(1);
	seHandle.setOpacity(1);
	swHandle.setOpacity(1);
}
function hideHandles() {
	neHandle.setOpacity(0);
	nwHandle.setOpacity(0);
	seHandle.setOpacity(0);
	swHandle.setOpacity(0);
}
function addMiniBox(amap) {
	minibox.addTo(amap);
	neHandle.addTo(amap);
	nwHandle.addTo(amap);
	seHandle.addTo(amap);
	swHandle.addTo(amap);
	updateHandles();
}
function removeMiniBox() {
	minibox.remove();
	neHandle.remove();
	nwHandle.remove();
	seHandle.remove();
	swHandle.remove();
}
function updateHandles() {
	neHandle.setLatLng(minibox.getBounds().getNorthEast());
	nwHandle.setLatLng(minibox.getBounds().getNorthWest());
	seHandle.setLatLng(minibox.getBounds().getSouthEast());
	swHandle.setLatLng(minibox.getBounds().getSouthWest());
}

function onHandleOver(e) {
	minimap.dragging.disable();
}
function onHandleOut(e) {
	minimap.dragging.enable();
}

neHandle.on('mouseover', onHandleOver);
nwHandle.on('mouseover', onHandleOver);
seHandle.on('mouseover', onHandleOver);
swHandle.on('mouseover', onHandleOver);
neHandle.on('mouseout', onHandleOut);
nwHandle.on('mouseout', onHandleOut);
seHandle.on('mouseout', onHandleOut);
swHandle.on('mouseout', onHandleOut);

// Methods to start resizing a selection
// The opposite corner from the one that is pressed is used as the anchor
neHandle.on('dragstart', function (e) {
	resizeAnchor = swHandle.getLatLng();
	resizeMove = neHandle;
	hideHandles();
});
nwHandle.on('dragstart', function (e) {
	resizeAnchor = seHandle.getLatLng();
	resizeMove = nwHandle;
	hideHandles();
});
seHandle.on('dragstart', function (e) {
	resizeAnchor = nwHandle.getLatLng();
	resizeMove = seHandle;
	hideHandles();
});
swHandle.on('dragstart', function (e) {
	resizeAnchor = neHandle.getLatLng();
	resizeMove = swHandle;
	hideHandles();
});

// Resizes the minimap box and the regular box while being dragged
function onResizeMove(e) {
	if (resizeAnchor != null) {
		minibox.setBounds([resizeAnchor, resizeMove.getLatLng()]);
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
		}
	}
}
neHandle.on('drag', onResizeMove);
nwHandle.on('drag', onResizeMove);
seHandle.on('drag', onResizeMove);
swHandle.on('drag', onResizeMove);

// Recenters the camera and resets dragging variables
function onResizeUp(e) {
	if (resizeAnchor != null) {
		minimap.fitBounds(minibox.getBounds());
		resizeAnchor = null;
		resizeMove = null;
		showHandles();
	}
}
neHandle.on('dragend', onResizeUp);
nwHandle.on('dragend', onResizeUp);
seHandle.on('dragend', onResizeUp);
swHandle.on('dragend', onResizeUp);

// Keep track of where the minimap was when it starts getting dragged
function onMiniDown(e) {
	miniStart = minimap.getBounds().getNorthEast();
	hideHandles();
}
minimap.on('dragstart', onMiniDown);

// Make minimap box stay centered while dragging around minimap
function onMiniMove(e) {
	if (miniStart != null) {
		// get how much the minimap view moved, and move the rectangle by that amount
		var offLat = minimap.getBounds().getNorth() - miniStart.lat;
		var offLng = minimap.getBounds().getEast() - miniStart.lng;
		minibox.setBounds([[minibox.getBounds().getSouth() + offLat, minibox.getBounds().getWest() + offLng],[minibox.getBounds().getNorth() + offLat, minibox.getBounds().getEast() + offLng]]);
		if (boxes.length > 0) {
			// move the box on the normal map
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
		}
		miniStart = minimap.getBounds().getNorthEast();
	}
}
minimap.on('drag', onMiniMove);

// Reset things after a drag
function onMiniUp(e) {
	if (miniStart != null) {
		miniStart = null;
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setBounds(minibox.getBounds());
			showHandles();
		}
	}
}
minimap.on('dragend', onMiniUp);

// Starts a selection on the map
function onMouseDown(e) {
	clickStart = e;
	box = L.rectangle(L.latLngBounds(e.latlng, e.latlng), {fill: false, color: SELECTED_BOX_COLOR}).addTo(map);
	click = true;
	if (boxes.length > 0) {
		boxes[boxes.length - 1].setStyle({fill: true, color: OLD_BOX_COLOR});
	}
}
map.on('mousedown', onMouseDown);

function onMouseUp(e) {
	// if the mouse is clicked, try to select an old box instead of making a new one
	if (click) {
		// check if the mouse in in a box
		for (var i = 0; i < boxes.length; i++) {
			var cell = boxes[i];
			// select box if it is clicked on
			if (cell.getBounds().contains(e.latlng)){
				if (boxes.length > 0) {
					boxes[boxes.length - 1].setStyle({fill: true, color: OLD_BOX_COLOR});
				}
				// move the selected box to the end of the list so you can cycle through overlapping boxes
				boxes.splice(i, 1);
				boxes.push(cell);
				cell.setStyle({fill: false, color: SELECTED_BOX_COLOR});
				// update minimap for new selection
				minibox.setBounds(cell.getBounds());
				minimap.fitBounds(minibox.getBounds());
				updateHandles();
				break;
			}
		}
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setStyle({fill: false, color: SELECTED_BOX_COLOR});
		}
		box.remove();
		clickStart = null;
		box = null;
	}

	// add the new selection to the list of boxes if the mouse was dragged
	if (box != null) {
		if (boxes.length > 0) {
			boxes[boxes.length - 1].setStyle({fill: true, color: OLD_BOX_COLOR});
		}
		clickStart = null;
		boxes.push(box)
		box = null;
	}
	click = false;
}
map.on('mouseup', onMouseUp);

// Make a selection between the point where the mouse is and where it was initially pressed
function onMouseMove(e) {
	if (box != null) {
		// if the mouse hasn't moved much, it might just be a click and not a drag, so you shouldn't make a new box yet
		if (!click || e.layerPoint.distanceTo(clickStart.layerPoint) > MAX_CLICK_MOVE) {
			click = false;
			box.setBounds(L.latLngBounds(e.latlng, clickStart.latlng));
			minibox.addTo(minimap).setBounds(box.getBounds());
			addMiniBox(minimap);
			showHandles();
			minimap.fitBounds(box.getBounds());
		}
	}
}
map.on('mousemove', onMouseMove);

// End the current selection when the mouse leaves the map
function onMouseOut(e) {
	if (box != null) {
		box.remove();
		clickStart = null;
		box = null;
		if (boxes.length > 0) {
			minibox.setBounds(boxes[boxes.length - 1].getBounds());
			minimap.fitBounds(minibox.getBounds());
			boxes[boxes.length - 1].setStyle({fill: false, color: SELECTED_BOX_COLOR});
		} else {
			removeMiniBox();
		}
	}
	click = false;
}
map.on('mouseout', onMouseOut);

// Remove the box at the end of the list of boxes, which should be the selected box
function undoBox() {
	if (boxes.length > 0) {
		boxes[boxes.length - 1].remove();
		boxes.pop();
		if (boxes.length > 0) {
			minibox.setBounds(boxes[boxes.length - 1].getBounds());
			minimap.fitBounds(minibox.getBounds());
			boxes[boxes.length - 1].setStyle({fill: false, color: SELECTED_BOX_COLOR});
			updateHandles();
		} else {
			removeMiniBox();
		}
	}
}

// Remove all boxes
function clearBoxes() {
	for (var i = boxes.length - 1; i >= 0; i--) {
		boxes[i].remove();
		boxes.pop();
	}
	removeMiniBox();
}

var pending = 0;
var failed = false;
// Send boxes in a window
// TODO Have some kind of warning when sendBoxes is called with no selections
// 		in case someone accidentally pressed submit twice
function sendBoxes() {
	if (pending == 0) {
		failed = false;
		$("#sending").show();
		$("#warning").hide();
		if (boxes.length == 0) {
			updateMap(false);
		}
		for (var i = boxes.length-1; i >= 0; i--) {
			pending++;
			var select = boxes[i];
			var data = [
				{name:"lat1", value:select.getBounds().getNorth()},
				{name:"lon1", value:select.getBounds().getEast()},
				{name:"lat2", value:select.getBounds().getSouth()},
				{name:"lon2", value:select.getBounds().getWest()}
			];
			data = data.concat($('#selection-form').serializeArray());
			console.log(select);
			$.post("/e4e/ml_training_map/harpyie_web/tag/spawn/", data)
			.fail(function() {
				$("#warning").show();
				failed = true;
			})
			.always(function() {
				pending--;
				updateMap(false);
			});
		}
	}
}
function updateMap(first) {
	if (pending == 0) {
		$("#sending").hide();
		if (!failed) {
			data = first ? [] : [{name:"complete", value:"yes"}];
			
			$.getJSON("/e4e/ml_training_map/harpyie_web/tiles/retrieve/", data, function(response) {
				mapBounds = [[response.lat1, response.lon1], [response.lat2, response.lon2]];
        updateBounds();
				lyr.setUrl('/static/imgs/{z}/{x}/{y}.png');
				mlyr.setUrl('/static/imgs/{z}/{x}/{y}.png');

				clearBoxes();
			});
		}
	}
}

updateMap(true);
$("#warning").hide();
$("#sending").hide();
